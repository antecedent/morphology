<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Unsupervised morphology induction using novel word prediction</title>
    <style type="text/css">
        * {
            font-family: 'Segoe UI', Helvetica, Arial, sans-serif;
        }

        #language a, #snapshot a {
            display: inline-block;
            padding: 10px;
            margin: 10px;
            background: #DDE2E8;
            transition: background 0.2s linear;
            text-decoration: none;
            color: black;
            border-radius: 5px;
        }

        #language a:hover {
            background: #CEF;
        }

        #snapshot a {
            background: #E8DEE5;
        }

        #snapshot a:hover {
            background: #FCE;
        }

        #time-series {
            height: 300px;
            width: 600px;
        }

        #plot-dialog {
            font-size: 14px;
        }

        #invention-dialog {
            overflow: auto;
            font-size: 14px;
        }

        .tasks li {
            color: gray;
        }

        .tasks li.completed {
            color: green;
        }

        .tasks li.initiated, .tasks li.progress {
            color: black;
        }

        .tasks li.failed {
            color: crimson;
        }

        canvas {
            display: block;
            margin: 0 auto;
        }

        .cluster a, .morphotactics a {
            margin: 10px;
            margin-right: 30px;
            display: block;
            float: left;
        }

        .cluster, .morphotactics {
            overflow: auto;
            background: #EEE;
            margin: 10px;
            padding: 10px;
            transition: background 0.2s linear;
        }

        .morphotactics {
            background: #555;
            color: white;
        }

        .cluster:hover {
            background: #EEF8FF;
        }

        .cluster p, .morphotactics p {
            font-size: 14px;
        }

        .divergence-notice {
            padding: 15px;
            margin: 15px 10px;
            background: lightyellow;
        }

        .success {
            color: green;
        }

        .hidden {
            display: none;
        }

        .network, .network-in-preparation {
            width: 100vw;
            height: 100vh;
            position: fixed;
            left: 0;
            top: 0;
            background: white;
        }

        .network {
            z-index: 1;
        }

        .network-in-preparation {
            z-index: 0;
        }

        header {
        }

        html, body {
            margin: 0;
            padding: 0;
        }

        .network .wait {
            margin-top: 45vh !important;
            font-size: 5vh;
            text-align: center;
        }

        section, header {
            margin: 20px;
        }

        section.results-section {
            margin: 0;
            padding: 0;
        }

        .status, .actions {
            position: fixed;
            bottom: 10px;
            left: 10px;
            z-index: 2;
        }

        .actions {
            left: auto;
            right: 10px;
        }

        .actions a {
            text-decoration: none;
            color: black;
            transition: color 0.2s linear;
        }

        .actions a:hover {
            color: #39c;
        }

        #segmentation-dialog {
            text-align: center;
        }

        #segmentation-input {
            margin: 0 auto;
            width: 450px;
            height: 125px;
            display: block;
            border: 1px solid lightgray;
            padding: 2px;
            font-family: 'Segoe UI', sans-serif;
        }

        #segmentation-output {
            margin: 0 auto;
            width: 450px;
            height: 125px;
            display: none;
            text-align: left;
            border: 1px solid lightgray;
            padding: 2px;
            overflow: auto;
        }

        #segmentation-button {
            margin: 10px auto;
        }

        .word {
            display: inline-block;
            padding-right: 6px;
        }

        .word.segmented {
            background: #e6ffcc;
        }

    </style>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/luminous-lightbox/2.0.0/luminous-basic.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.css">
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <link rel="stylesheet" href="https://code.jquery.com/ui/1.12.1/themes/base/jquery-ui.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.js"></script>
    <script
      src="https://code.jquery.com/jquery-3.3.1.min.js"
      integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8="
      crossorigin="anonymous"></script>
    <script src="https://code.jquery.com/ui/1.12.1/jquery-ui.js"></script>
    <script src="visualization.js"></script>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/luminous-lightbox/2.0.0/Luminous.min.js"></script>
    <script>
        $(() => {
            window.text = '';

            window.readyToRender = false;

            window.timeSeries = [];

            window.results = {};

            window.connectionOpen = false;

            window.rendering = false;

            window.firstRendering = true;

            window.renderedScore = 0;

            window.imagesOn = false;

            window.autoRefresh = true;

            window.worker = null;

            window.networkInterval = null;

            window.paused = false;

            window.networksDrawn = new Set;
            window.drawingNetworkNow = false;

            window.segmenting = false;

            window.segmentationTimeouts = [];

            window.similarity = (w1, w2) => {
                if (w1 == w2) {
                    return 1.0;
                }
                if (w1.length > w2.length) {
                    [w1, w2] = [w2, w1];
                }
                var result = 0;
                for (var i = 1; i < w1.length + 1; i++) {
                    if (w2.startsWith(w1.substring(0, i))) {
                        result += 1;
                    }
                }
                for (var i = 0; i < w1.length - 1; i++) {
                    if (w2.endsWith(w1.substring(i))) {
                        result += 1;
                    }
                }
                return result / w2.length;
            };

            window.LCS = (s1, s2) => {
                var result = [];
                for (var i=0; i<=s1.length; i++) {
                    result.push([]);
                    for (var j=0; j<=s2.length; j++) {
                        var currValue = 0;
                        if (i==0 || j==0) {
                            currValue = 0;
                        } else if (s1.charAt(i-1) == s2.charAt(j-1)) {
                            currValue = result[i-1][j-1] + 1;
                        } else {
                            currValue = Math.max(result[i][j-1], result[i-1][j]);
                        }
                        result[i].push(currValue);
                    }
                }

                var i = s1.length;
                var j = s2.length;

                var s3 = '';
                while (result[i][j] > 0) {
                    if(s1.charAt(i-1) == s2.charAt(j-1) && (result[i-1][j-1] +1 == result[i][j])) {
                        s3 = s1.charAt(i-1) + s3;
                        i = i-1;
                        j = j-1;
                    } else if (result[i-1][j] > result[i][j-1])
                        i = i-1;
                    else
                        j = j-1;
                }
                return s3;
            };

            window.segment = (word) => {

                var info = results.getClusterInfo;
                var trainingWords = results.extractWords;
                var validationWords = results.getValidationSet;

                var allPrefixes = function* (string) {
                    for (var i = 1; i <= string.length; i++) {
                        yield string.substring(0, i);
                    }
                };

                var trace = (pieces, cluster) => {
                    if (pieces[0] === '⋉') {
                        return 0;
                    }
                    var best = 123456;
                    for (var m of cluster.morphemes) {
                        if (cluster.affix) {
                            var dist = (pieces[0] === Visualization.removeSubscripts(m)) ? 0 : pieces[0].length;
                        } else {
                            var m1 = pieces[0];
                            var m2 = Visualization.removeSubscripts(m);
                            if (m1.length > m2.length) {
                                [m1, m2] = [m2, m1];
                            }
                            var dist = m2.length - LCS(m1, m2).length;
                        }
                        for (var s of cluster.successors) {
                            var score = dist + trace(pieces.slice(1), s);
                            if (score <= best) {
                                best = score;
                            }
                        }
                        //console.log(pieces, cluster.morphemes.join(' '), best);
                    }
                    return best;
                };

                var segmentWord = (word) => {
                    var bestScore = 123456;
                    var bestHypothesis = word;

                    var hypotheses = [word[0]];
                    for (var i = 1; i < word.length; i++) {
                        var letter = word[i];
                        var length = hypotheses.length;
                        for (var j = 0; j < length; j++) {
                            var h = hypotheses[j];
                            hypotheses.push(h + letter);
                            hypotheses.push(h + '-' + letter);
                        }
                        // NOTE the 5
                        hypotheses = hypotheses.slice(length).filter(hypo => hypo.split('-').length <= 5);
                    }
                    for (var h of hypotheses) {
                        var pieces = ('⋊-' + h + '-⋉').split('-');
                        var score = trace(pieces, info.filter((c) => c.morphemes.includes('⋊'))[0]);
                        //console.log(h, score);
                        if (score <= bestScore) {
                            bestScore = score;
                            bestHypothesis = h;
                        }
                    }

                    return bestHypothesis;
                };

                var deploySegmentation = (word, hypothesis) => {
                    var escapedWord = word.replace(/[.?*+^$[\]\\(){}|-]/g, "\\$&");
                    // if (hypotheses.filter((h) => !h.novel).length > 0) {
                    //     hypotheses = hypotheses.filter((h) => !h.novel);
                    // }
                    // hypotheses.sort((l, r) => r.path.length - l.path.length);
                    // try {
                    //     var segmentation = hypotheses[0].path.join('-');
                    // } catch (error) {
                    //     debugger;
                    // }
                    var segmentation = hypothesis;
                    //console.log(word, segmentation);
                    var variations = [
                        [escapedWord.toLowerCase(), segmentation.toLowerCase()],
                        [escapedWord.toUpperCase(), segmentation.toUpperCase()],
                        [escapedWord[0].toUpperCase() + escapedWord.substring(1).toLowerCase(), segmentation[0].toUpperCase() + segmentation.substring(1).toLowerCase()]
                    ];
                    for (var [pattern, replacement] of variations) {
                        _text = _text.replace(new RegExp('([^\\w\']|^)(' + pattern + ')([^\\w\']|$)', 'g'), '$1' + replacement + '$3');
                    }
                };

                return segmentWord(word);
            };

            window.drawNetwork = () => {
                if (!results.network || drawingNetworkNow) {
                    return;
                }
                drawingNetworkNow = true;
                var tag = Date.now();
                var nodes = new vis.DataSet(results.network.nodes);
                var edges = new vis.DataSet(results.network.edges);
                var network = new vis.Network($('.network-in-preparation')[0], {nodes: nodes, edges: edges}, {
                    edges: {
                        arrows: 'to'
                    },
                    nodes: {
                        widthConstraint: {
                            maximum: 200
                        },
                        font: {
                            face: 'Roboto, "Segoe UI", Helvetica, Arial, sans-serif'
                        }
                    },
                    groups: {
                        leftMarginal: {
                            color: '#CAEFC2'
                        },
                        left: {
                            color: '#C2EFEB'
                        },
                        root: {
                            color: '#C2DDEF'
                        },
                        right: {
                            color: '#D4C2EF'
                        },
                        rightMarginal: {
                            color: '#E8C2EF'
                        }
                    }
                });
                network.on('afterDrawing', () => {
                    if (!networksDrawn.has(tag)) {
                        var link = $('.update-network').show().find('a').click(() => {
                            if (!networksDrawn.has(tag)) {
                                var newNetwork = $('.network-in-preparation')[0];
                                var oldNetwork = $('.network')[0];
                                $(newNetwork).removeClass('network-in-preparation').addClass('network');
                                $(oldNetwork).removeClass('network').addClass('network-in-preparation').empty();
                                $('.update-network').hide();
                                drawingNetworkNow = false;
                                networksDrawn.add(tag);
                            }
                            return false;
                        });
                        if (networksDrawn.size == 0) {
                            link.trigger('click');
                        }
                    }
                });
            };

            $('#auto-refresh').change(function () {
                autoRefresh = $(this).is(':checked');
            });


            window.showResults = () => {
                if (!results || !results.score || !readyToRender || window.rendering || !autoRefresh) {
                    return;
                }
                if (imagesOn == $('#images-on').is(':checked') && results.score <= renderedScore) {
                    return;
                }
                imagesOn = $('#images-on').is(':checked');
                var score = results.score;
                var renderingParameters = [results.renumberClusters[0],
                results.getAdjacencyMatrix[1],
                results.getRelevantEdges,
                results.generateLayout];
                window.rendering = true;
                $('.tasks li[data-task=render]').addClass('progress');
                var k = 0;
                var clusterInfo = results.getClusterInfo;
                if (clusterInfo.length == 0) {
                    window.rendering = false;
                }

                var renderSingleImage = (image) => {

                    // NOTE
                    return;

                    if (!clusterInfo[k]) {
                        clusterInfo[k] = {
                            morphemes: []
                        };
                    }
                    if (k == 0 || clusterInfo[k].morphemes.length == 0) {
                        if (image) {
                            k++;
                        }
                        return;
                    }
                    var hue = parseInt(33 * (k % 10));
                    var div = $('<div class="cluster">');
                    if (!window.firstRendering) {
                        div.addClass('hidden');
                    }
                    if ($('#images-on').is(':checked')) {
                        var img = $('<img>').attr('src', image).attr('width', 200).attr('height', 200);
                        var a = $('<a>').attr('href', image).append(img).appendTo(div);
                        new Luminous(a[0]);
                    }
                    var h3 = $('<h3>' + k + ' grupė <span style="color: hsl(' + hue + ', 100%, 50%);">&bull;</span></h3>').appendTo(div);
                    //$('<p><em>' + (results.getClusterInfo[k].open ? 'Atvira klasė' : 'Uždara klasė') + '</em></p>').appendTo(div);
                    var morphemes = clusterInfo[k].morphemes.map(Visualization.removeSubscripts);
                    var subtypeCount = {};
                    for (var morpheme of morphemes) {
                        if (!subtypeCount.hasOwnProperty(morpheme)) {
                            subtypeCount[morpheme] = 0;
                        }
                        subtypeCount[morpheme]++;
                    }
                    morphemes = Array.from(Object.keys(subtypeCount)).map((m) => {
                        if (subtypeCount[m] > 1) {
                            m += ` (${subtypeCount[m]})`;
                        }
                        return m;
                    });
                    var p = $('<p>' + (morphemes.join(', ')) + '</p>').appendTo(div);
                    $('.results-section').append(div);
                    if (image) {
                        k++;
                    }
                    if (k == Math.min(clusterInfo.length, Visualization.maxNumClusters) && image) {
                        if (!window.firstRendering) {
                            $('.results-section > .cluster:not(.hidden)').remove();
                        }
                        $('.results-section > .cluster.hidden').removeClass('hidden');
                        window.rendering = false;
                        window.firstRendering = false;
                        window.renderedScore = score;
                    }
                };

                if ($('#images-on').is(':checked')) {
                    Visualization.createImages(
                        renderingParameters[0],
                        renderingParameters[1],
                        renderingParameters[2],
                        renderingParameters[3],
                        renderSingleImage
                    );
                } else {
                    for (k = 0; k < clusterInfo.length; k++) {
                        renderSingleImage(null);
                    }
                    if (!window.firstRendering) {
                        $('.results-section > .cluster:not(.hidden)').remove();
                    }
                    $('.results-section > .cluster.hidden').removeClass('hidden');
                    window.rendering = false;
                    window.firstRendering = false;
                    window.renderedScore = score;
                }
                $('.tasks li[data-task=render]').removeClass().addClass('completed');
                $('section:not(.results-section)').hide();
                $('.results-section').show();
                var validation = results.getValidationSet;
                if (validation instanceof Array) {
                    validation = new Set(validation);
                } else if (!(validation instanceof Set)) {
                    validation = new Set;
                }
                var neologisms = results.inventWords.map((w) => {
                    if (validation.has(w)) {
                        return '<span class="success">' + w + '</span>';
                    }
                    return w;
                });
                neologisms.sort();
                $('.neologisms').html(neologisms.join(', '));
                var percentage = results.score * 100;
                var d = new Date;
                $('.success-rate').text(percentage.toFixed(2));
                if (isNaN(percentage)) {
                    $('.morphotactics').hide();
                }
                if (isNaN(percentage) || percentage == 0) {
                    $('.divergence-notice').show();
                }

            };

            var hash = (text) => [
                text.length,
                text.substring(0, 100).replace(/:/g, ''),
                text.substring(text.length - 100, text.length).replace(/:/g, ''),
                parameters.numSalientSubstrings,
                parameters.preferredMorphemeLength,
                parameters.minCommutationStrength,
                parameters.trainingSetProportion1,
                parameters.trainingSetProportion2
            ].join(':');

            var run = (text) => {
                window.text = text;
                window.parameters = {};
                $('.parameters-section input').each(function () {
                    parameters[$(this).data('key')] = parseFloat($(this).val());
                    if ($(this).is('[type=checkbox]')) {
                        parameters[$(this).data('key')] = $(this).is(':checked');
                    }
                    if (isNaN(parameters[$(this).data('key')])) {
                        return;
                    }
                    parameters.shouldSplit = $('#splitting-on').is(':checked');
                });
                var textKey = hash(text);
                if (localStorage.getItem(textKey)) {
                    parameters.commutations = JSON.parse(localStorage.getItem(textKey));
                }
                var clusteringsKey = [textKey, 'clusterings', parameters.precisionMultiplier, parameters.recallMultiplier, parameters.MDLMultiplier, parameters.shouldSplit].join(':');
                if (localStorage.getItem(clusteringsKey)) {
                    parameters.clusterings = JSON.parse(localStorage.getItem(clusteringsKey));
                }
                // var iterator = $('.iteration');
                // for (var i = parseInt(Math.log(parameters.pruningThreshold) / Math.log(3)) + 5; i > 0; i--) {
                //     $(iterator[0].outerHTML.replace(new RegExp('{' + iterator.data('counter') + '}', 'g'), i)).insertAfter(iterator);
                // }
                // iterator.detach();
                window.history.pushState(null, window.language, '#' + window.language);
                window.onpopstate = function() {
                    window.location.assign('');
                };
                $('.texts-section, .parameters-section').hide();
                worker = new Worker('worker.js');
                $('.tasks li').removeClass();
                $('.progress').text('0');
                worker.onmessage = (e) => {
                    var element = $('.tasks li[data-task="?"]'.replace('?', e.data.task));
                    element.removeClass().addClass(e.data.state);
                    if (e.data.state == 'progress') {
                        $('[data-task="?"] .progress'.replace('?', e.data.task)).text(e.data.progress);
                    }
                    if (e.data.state == 'completed') {
                        element.find('.progress').text('100');
                        var key = e.data.task.replace(/\.\d+$/, '');
                        results[key] = e.data.result;
                        if (e.data.task == 'refineCommutations') {
                            try {
                                localStorage.setItem(textKey, JSON.stringify(e.data.result.map((c) => [Array.from(c[0]), c[1], c[2]])));
                            } catch (error) {
                                console.log('Local storage quota exceeded.');
                                //localStorage.clear();
                            }
                        }
                        if (e.data.task == 'getClusterings') {
                            try {
                                localStorage.setItem([textKey, 'clusterings', parameters.precisionMultiplier, parameters.recallMultiplier, parameters.MDLMultiplier, parameters.shouldSplit].join(':'), JSON.stringify(e.data.result));
                            } catch (error) {
                                console.log('Local storage quota exceeded.');
                                //localStorage.clear();
                            }
                        }
                        if (e.data.task == 'network') {
                            if (window.networkInterval === null) {
                                drawNetwork();
                                window.networkInterval = window.setInterval(drawNetwork, 300000);
                            }
                        }
                        if (e.data.task == 'initialized') {
                            window.setTimeout(() => worker.postMessage({action: 'run'}), 1);
                        }
                        if (e.data.task == 'ready') {
                            readyToRender = true;
                            connectionOpen = false;
                            $('header').hide();
                            showResults();
                            if (!paused) {
                                window.setTimeout(() => worker.postMessage({action: 'run'}), 1);
                            }
                        }
                        if (e.data.task == 'beginPayload') {
                            connectionOpen = true;
                        }
                        if (e.data.task == 'score') {
                            function pad (str, max) {
                                str = str.toString();
                                return str.length < max ? pad("0" + str, max) : str;
                            }
                            var d = new Date;
                            timeSeries.push({
                                time: `${d.getFullYear()}-${pad(d.getMonth() + 1, 2)}-${pad(d.getDate(), 2)} ${pad(d.getHours(), 2)}:${pad(d.getMinutes(), 2)}:${pad(Math.floor(d.getSeconds()), 2)}`,
                                score: results.score * 100
                            });
                        }
                        if (e.data.task == 'segment') {
                            $('.preparing-segments').hide();
                            $('.download-segments').show();
                        }
                        if (e.data.task == 'done') {
                            worker.terminate();
                        }
                    }
                    if (e.data.state == 'failed') {
                        worker.terminate();
                        console.log(e.data.stack);
                    }
                };
                worker.postMessage({
                    action: 'initialize',
                    text: text,
                    vertexRadius: Visualization.vertexRadius,
                    canvasWidth: Visualization.width,
                    canvasHeight: Visualization.height,
                    parameters: parameters
                });
            };

            $('#language a, #snapshot a').click(function () {
                window.language = $(this)[0].innerText;
                $.get($(this).data('src'), $(this).is('#snapshot a') ? restoreSnapshot : run);
                return false;
            });

            window.restoreSnapshot = (snapshot) => {
                $('#pause, #resume, #segment, #plot').hide();
                results.score = snapshot.score;
                results.network = snapshot.network;
                results.inventWords = snapshot.inventedWords;
                results.getValidationSet = new Set(snapshot.matchedInventedWords);
                $('.success-rate').text((100 * results.score).toFixed(2));
                $('header, section:not(.results-section)').hide();
                $('.results-section').show();
                drawNetwork();
            };

            $('#upload').change(function () {
                var reader = new FileReader;
                var file = document.getElementById('upload').files[0];
                reader.readAsText(file);
                if (file.name.endsWith('.json')) {
                    reader.onloadend = () => {
                        var snapshot = JSON.parse(reader.result);
                        restoreSnapshot(snapshot);
                    };
                } else {
                    reader.onloadend = () => run(reader.result);
                }
            });

            $('#segment').click(function() {
                $('#pause').trigger('click');
                $('#segmentation-input').val('').show();
                $('#segmentation-output').val('').hide();
                $('#segmentation-button').prop('disabled', false).click(function() {
                    $('#segmentation-button').prop('disabled', true);
                    var words = $('#segmentation-input').hide().val().toLowerCase().split(/[\s\d:]+/);
                    var output = '';
                    for (var word of words) {
                        word = word.replace(/^[!"#$%&\'()*+,-./:;<=>?@\[\\\]\^_`{|}~—‘’„“”¿¡«»-]*/, '');
                        word = word.replace(/[!"#$%&\'()*+,-./:;<=>?@\[\\\]\^_`{|}~—‘’„“”¿¡«»-]*$/, '');
                        output += '<span class="word">' + word + '</span>';
                        $('#segmentation-output').html(output).show();
                    }
                    var t = 0;
                    for (var word of $('#segmentation-output .word')) {
                        window.setTimeout(function(word) {
                            $(word).html(segment($(word).html())).addClass('segmented');
                        }, t++ * 10, word);
                    }
                });
                $('#segmentation-dialog').dialog({width: 500, height: 300});
                return false;
            });

            window.download = function () {
                var element = document.createElement('a');
                var snapshot = {
                    score: results.score,
                    network: results.network,
                    inventedWords: results.inventWords,
                    matchedInventedWords: results.inventWords.filter(w => results.getValidationSet.has(w)),
                };
                var blob = new Blob([JSON.stringify(snapshot)], {type: 'application/json'});
                element.setAttribute('href', URL.createObjectURL(blob));
                element.setAttribute('download', 'snapshot-' + (new Date).toISOString().replace(/[^\d]/g, '') + '.json');
                element.style.display = 'none';
                document.body.appendChild(element);
                element.click();
                document.body.removeChild(element);
            };

            $('#pause').click(function() {
                $(this).hide();
                $('#resume').show();
                paused = true;
                return false;
            });

            $('#resume').click(function() {
                $(this).hide();
                $('#pause').show();
                paused = false;
                worker.postMessage({action: 'run'});
                return false;
            });

            window.setInterval(() => {
                Plotly.newPlot('time-series', [{
                    type: 'scatter',
                    mode: 'lines',
                    x: timeSeries.map((t) => t.time),
                    y: timeSeries.map((t) => t.score)
                }]);
            }, 10000);

            $('#plot').click(function() {
                $('#plot-dialog').dialog({width: 625, height: 400});
                return false;
            });

            $('#invent').click(function() {
                var inventions = results.inventWords.map((w) => {
                    if (results.getValidationSet.has(w)) {
                        return '<span class="success">' + w + '</span>';
                    }
                    return w;
                });
                inventions.sort();
                $('#invention-dialog').html(inventions.join(', ')).dialog({width: 400, height: 400});
                return false;
            });

            $(document).tooltip();


            if (window.location.hash) {
                for (var link of document.querySelectorAll('#language a')) {
                    if (link.innerText === window.location.hash.replace(/#/, '')) {
                        link.click();
                        break;
                    }
                }
            }


        });

    </script>
</head>
<body>
    <header>
        <h1>Unsupervised morphology induction using novel word prediction</h1>
        <p>&copy; 2018 Ignas Rudaitis, Vilnius University</p>
    </header>
    <section class="texts-section">
        <h2>Input</h2>
        <p style="display: none;"><input id="splitting-on" checked type="checkbox"> Mitigate the conflation of homonymous affixes (highly multiplies the number of inital clusters, which triggers pruning)</p>
        <dl>
            <dt>Open a local file:</dt>
            <dd>
                <p><input id="upload" type="file"></p>
                <p><em>Notes:</em> The file will not be uploaded anywhere; all processing takes place in the browser. Only plain text files (.txt) are accepted.</p>
            </dd>
            <!-- <dt>Preview a completed analysis of some of the texts below:</dt>
            <dd id="snapshot">
                <a href="#" data-src="snapshots/english.json">English</a>
                <a href="#" data-src="snapshots/lithuanian.json">Lithuanian</a>
            </dd> -->
            <dt>Alternatively, use the present device to analyze a text from the <a href="http://wortschatz.uni-leipzig.de/en/download">Leipzig Corpora Collection</a> (100K sentences each):</dt>
            <dd id="language">
                <a href="#" data-src="eng_news_2016_100K-sentences.txt">English</a>
                <a href="#" data-src="est_news_2014_100K-sentences.txt">Estonian</a>
                <a href="#" data-src="fin_news_2005-2007_100K-sentences.txt">Finnish</a>
                <a href="#" data-src="fra_news_2010_100K-sentences.txt">French</a>
                <a href="#" data-src="kat_wikipedia_2016_100K-sentences.txt">Georgian</a>
                <a href="#" data-src="deu_news_2015_100K-sentences.txt">German</a>
                <a href="#" data-src="ell_news_2011_100K-sentences.txt">Greek</a>
                <a href="#" data-src="lat_wikipedia_2016_100K-sentences.txt">Latin</a>
                <a href="#" data-src="lav_newscrawl_2016_100K-sentences.txt">Latvian</a>
                <a href="#" data-src="lit_newscrawl_2016_100K-sentences.txt">Lithuanian</a>
                <a href="#" data-src="pol_news_2008_100K-sentences.txt">Polish</a>
                <a href="#" data-src="ron_news_2015_100K-sentences.txt">Romanian</a>
                <a href="#" data-src="rus_news_2010_100K-sentences.txt">Russian</a>
                <a href="#" data-src="por_wikipedia_2016_100K-sentences.txt">Portuguese</a>
                <a href="#" data-src="spa_news_2011_100K-sentences.txt">Spanish</a>
                <a href="#" data-src="swa_wikipedia_2016_100K-sentences.txt">Swahili</a>
                <a href="#" data-src="swe_news_2007_100K-sentences.txt">Swedish</a>
                <a href="#" data-src="tur_news_2005_100K-sentences.txt">Turkish</a>
            </dd>
        </dl>
    </section>
    <section class="parameters-section" style="display: none;">
        <h2>Parameters</h2>
        <table>
            <!-- <tr>
                <td>Kaimynysčių įtraukties koeficientas</td>
                <td><input type="number" data-key="edgeThresholdFactor" value="5"></td>
            </tr> -->
            <tr>
                <td># of salient substrings</td>
                <td><input data-key="numSalientSubstrings" type="number" value="3000"></td>
            </tr>
            <tr>
                <td>Preferred length of an affix</td>
                <td><input data-key="preferredMorphemeLength" type="number" value="3"></td>
            </tr>
            <tr>
                <td>Minimum # of examples to prove a commutation</td>
                <td><input data-key="minCommutationStrength" type="number" value="100"></td>
            </tr>
            <tr>
                <td>Maximum # of commutations before refinement</td>
                <td><input data-key="maxNumPrimaryCommutations" type="number" value="3000"></td>
            </tr>
            <tr>
                <td>Maximum # of morphemes to consider</td>
                <td><input data-key="pruningThreshold" type="number" value="3000"></td>
            </tr>
            <tr style="display: none;">
                <td>Relative size of training/validation sets</td>
                <td><input data-key="trainingSetProportion1" value="1" type="number" style="width: 4em;"> : <input data-key="trainingSetProportion2" value="1" type="number" style="width: 4em;"></td>
            </tr>
            <!-- <tr>
                <td>Grupavimo operacijų skaičius</td>
                <td><input data-key="numClusteringOperations" type="number" value="300"></td>
            </tr> -->
            <tr>
                <td>Relative weights of precision, recall and MDL scores</td>
                <td><input data-key="precisionMultiplier" type="number" value="10" style="width: 3em;"> : <input data-key="recallMultiplier" type="number" value="10" style="width: 3em;"> : <input data-key="MDLMultiplier" type="number" value="1" style="width: 3em;"></td>
            </tr>
            <!-- <tr>
                <td>Perrinkti grupavimo sprendimų poaibius</td>
                <td><input data-key="checkSubsets" type="checkbox"></td>
            </tr> -->
            <!-- <tr>
                <td>Klasės uždarumo slenksčio koeficientas</td>
                <td><input type="number" data-key="openClassThresholdFactor" value="100"></td>
            </tr> -->
        </table>
    </section>
    <section class="progress-section">
        <h2>Progress</h2>
        <ul class="tasks">
            <li data-task="extractWords">Extract words</li>
            <li data-task="makePrefixTree">Build a prefix tree for training words (<span class="progress">0</span>%)</li>
            <li data-task="getSalientSubstrings">Detect salient substrings</li>
            <li data-task="commute">Perform commutation tests (<span class="progress">0</span>%)</li>
            <li data-task="refineCommutations">Refine commutations (<span class="progress">0</span>%)</li>
            <li data-task="getBigrams">Count bigrams of commuting substrings</li>
            <li data-task="getAdjacencyMatrix">Compose an adjacency list (<span class="progress">0</span>%)</li>
            <li data-task="restoreStateFromCache">Resume previous progress (<span class="progress">0</span>%)</li>
            <!--<li data-task="doFirstPassClustering">Sugrupuoti morfemas pagal kaimynystės savybes</li>-->
            <!-- <li data-task="generateLayout">Išdėstyti kaimynystės schemą plokštumoje (<span class="progress">0</span>%)</li>
            <li data-task="getRelevantEdges">Išrinkti rodykles iš kaimynystės matricos (<span class="progress">0</span>%)</li> -->
            <li data-task="doSecondPassClustering">Pre-cluster candidate morphemes (<span class="progress">0</span>%)</li>
            <!--<li class="iteration" data-counter="i">
                <strong>{i} bandymas grupuoti kandidatines morfemas:</strong>
                <ul>
                    <li data-task="doSecondPassClustering.{i}">Patikslinti morfemų grupavimą (<span class="progress">0</span>%)</li>
                    <li data-task="renumberClusters.{i}">Atnaujinti grupių numeraciją</li>
                    <li data-task="getClusterInfo.{i}">Nustatyti morfemų grupių tipus</li>
                    <li data-task="inventWords.{i}">Kurti naujadarus (<span class="progress">0</span>%)</li>
                </ul>
            </li>
        -->
            <!-- <li data-task="render">Nupiešti kaimynystės diagramas (<span class="progress">0</span>%)</li> -->
        </ul>
    </section>
    <section class="results-section" style="display: none;">
        <!-- <h2>Rezultatai</h2>
        <p><a href="" target="_blank">Analizuoti kitą tekstą (naujame skirtuke)</a></p>
        <p><input id="auto-refresh" checked type="checkbox"> Atnaujinti informaciją automatiškai</p>
        <p><input id="images-on" type="checkbox"> Rodyti morfotaktinius ryšius grafiškai</p> -->
        <!-- <p class="preparing-segments" data-task="segment">Ruošiamas segmentuotas tekstas (<span class="progress">0</span>%)</p>
        <p class="download-segments" style="display: none;"><a href="#" target="_blank">Atsisiųsti segmentuotą tekstą</a></p>
        <p><a href="#" class="download-results" target="_blank">Išsaugoti analizės rezultatus vėlesnei peržiūrai</a></p> -->
        <!-- <div class="divergence-notice" style="display: none;">
            Naujadarų generavimas nedavė rezultatų. Gali reikėti pasirinkti ilgesnį tekstą arba tiesiog paleisti algoritmą dar kartą.
        </div> -->
        <div class="network">
            <p class="wait">Please wait, the morphotactic graph is loading...</p>
        </div>
        <div class="status">
            Score: <span class="success-rate">0</span>%
            <span class="update-network" style="display: none;"> &bull; <a href="#">Refresh graph</a></span>
        </div>
        <div class="actions">
            <a id="segment" href="#" title="Segmentation"><i class="material-icons">line_style</i></a>
            <a id="plot" href="#" title="Score over time"><i class="material-icons">insert_chart</i></a>
            <a id="invent" href="#" title="Word predictions"><i class="material-icons">star</i></a>
            <a id="pause" href="#" title="Pause"><i class="material-icons">pause</i></a>
            <a id="resume" style="display: none;" href="#" title="Resume"><i class="material-icons">play_arrow</i></a>
        </div>
        <div class="network-in-preparation"></div>
    </section>
    <div id="plot-dialog" style="display: none;" title="Score over time">
        <div id="time-series">
        </div>
    </div>
    <div id="invention-dialog" style="display: none;" title="Word predictions">
    </div>
    <div id="segmentation-dialog" style="display: none;" title="Segmentation">
        <p style="text-align: center;">Please provide some text to segment:</p>
        <textarea id="segmentation-input"></textarea>
        <div id="segmentation-output"></div>
        <button id="segmentation-button">Segment</button>
    </div>
</body>
</html>
